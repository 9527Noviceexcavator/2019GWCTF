### babyRSA2

这道题可以算是给各位师傅复习一下rsa一些攻击方法了

#### level 1

共模攻击，这个大家应该很熟悉了

```python
def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)

def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m

# 共模攻击
e1 = 2333
e2 = 23333
n = 8788243810113198481764566947869508914607026957466489668727548073613496825679400591687813426342686034806081353790472216192635172094987395128834590030497381
c1 = 4799918654649006116940502215835347906203162902787669199307383957409192303134738166614010930829808272183136103896570661157044610508330743272839870684458619
c2 = 3517433402358387844096791333634390193378704559086526036995918508702312833687284786927630246590107124972191795462221141049323183791880150003945625070468406
s = egcd(e1, e2)
s1 = s[1]
s2 = s[2]
# 求模反元素
if s1<0:
    s1 = - s1
    c1 = modinv(c1, n)
elif s2<0:
    s2 = - s2
    c2 = modinv(c2, n)
m = (pow(c1,s1,n)*pow(c2,s2,n)) % n
print m
```

#### level 2

低指数攻击 
$$
c = m^e\ mod\ n \\
m^e = kn\ +\ c \\
m = \sqrt[e]{kn\ +\ c}
$$

```python
n = 0x95021fbb4df8692ddbf928981593dfebb5a655b3a3690a9d3a491947f570ebdcd60066123e97c835744071e7ed5365b0632a12a828d11a01d6100948fb6d129d5f01d83a39c5ea84d240235f3b01c3ea8ba81826a49fdce32935d00705831c6ff0734ceec19d6d91f8578db0c715a53dd9642f9219b5cd42d4e71e257ad9df95e9a89a6e87a3e863bc62ee2d9511600a79ca7e0328cc5bf6986d09eaa6d65a7ecfadc028f92181d399271474af96241d365d19c3c9ad8e5b5a46a92af2493ee1e363a274afc76625c187b088cee4af7b7ec20a7433497e12f636e357ed77dbaeb89c8b89a4467befff2a68b2e9e226c3c07897f7769030a1ac1311730124c789f16abef45ad581fdd019468864d809e49586dde58141a39218a6b33850c6cfdfae5719bfc96f0b6f3aad62279979936915070865b0b52f2c78041898cd7d64af159281041aae8620eacc1de384fb92c43726c0afae49a98e5c64ef2287c3fe8d41593eb3673bcb84e1a48428cd02a0a5a3dfaffc4cb91858fbcb50e7027d09050578e12e62e78823da46de6e05b099adfb5061cf39bf7bf5d87f29e48274731c3d662314bba51d87a409eb849f123aea50db4ea05dfaba4137c5ccce2d458d8c2ae26916ea803d98e5227cd3c642e1414800c9216e8e86ba7d194e2cd6eaeff163bd7c12a2eb28219170d87a9961a348cf10b6432b4be1168957cccae6f91e6fL
e = 3
c = 0xde10e648e44b37de11f430ed08adf886a3622b23d18f01614710b47eeb4d227c4955c686b85e2a807f842b6d4e72629f44b037bb0f500a3cf3ec9514423ffc7de2e7f0994a817dabaecd583e29cbb198efc13edb8043ff48c54ba9bc4d29f910b8c2030dad4f316b33645150b251f657a45da96728c5fa935114226d776773e95aa334a956b729ae6f0e9a30dfc4caea3a1f3b4a269e64c9a058f15e0dcd8c60f99d04e519c6d31a26a1e57a951092b2826e42aee044f7d8822757f19167ed9L
for i in xrange(200000000):
    if gmpy2.iroot(c+n*i,3)[1] == 1:
        res = gmpy2.iroot(c+n*i,3)[0]
        print res
        break
```

#### level 3

已知高位 p  ，factor with high bits known

想进一步了解就查看https://www.jianshu.com/p/1a0e876d5929

```python
from sage.all import *
n = 0xeb4f8c45336c229371fd73a252b24dd3bf8b3cdc1bb1864f140fd63c88d47c44ba228bebe223fe53c7eaf88678b780821a6660b2726506216554990a5dda178ee04a47c7f1974fc8f8268d081bbb2be7e7353ccf36fecfce5f5f82722d064928f2d60844373c52b4d1db9dc41f7f16807c5b4356c4d2290811e25c51ef1227aa6e893d37dd8743e391fa638d77d0c55e4fb331576602128333d4be95f06523521e7511b39fc20111c88f2635b67e3531684d58ea6574179b5e63a862d073241f5ff91c97a45aa3d8e3287d8161a97728d2e19d72669f39f9e6ad10677bb563bdef30d0dcfa719c2f1836bd02b73d21dbecc11717b54c45d415d3f423ce6dfd8d
p4 = 0xfb2151c701f7667b53822fe625b95edee00c3a947b234eca47903ef62fb128d813a9c1acb328f3f7181d24ce31814cd1a69ac4b61b269e2b0eb7fbaabe9633d33a36d0715b4cd3860000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
cipher = 0x578620facc67a53183f1e68a010559969dcd5e20b91ac73c8277fd1c24965dea469884df2964204b37290cbe5359632db7afe4fc1ab3116e3ed91788cb99724baf0e98542ed273bc21b3c2e14ed197bf21764cf42e7975da493a28e88e4695ef49d88b68c38c69c4cbf152c4c44da19c2b38faf78f02973701a1f804e9f0cf2a0604932c5db83d18f9ba868171d04a0389d9a1a36482f935328adb3501f50008e167ad4066089780e2392b9f0ec61567a0323f2652a2d815e793e293a6c8357df692ffdcbf4384fb63448de2d13625a3089d8e7831e9d3942f7b160b47f9dd6f29911f9d34c8d6888ca11d226bc3df9f2a8d8ba75a6cece3b59a99b962cf7adeL
e2 = 65537
kbits = 448  #未知需要爆破的比特位数
PR.<x> = PolynomialRing(Zmod(n))
f = x + p4
roots = f.small_roots(X=2^kbits, beta=0.4) #进行爆破
if roots:        #爆破成功，求根
    p = p4+int(roots[0])
    assert n % p == 0
    q = n/int(p)
    phin = (p-1)*(q-1)
    d = inverse_mod(e2,phin)
    flag = pow(cipher,d,n)
    print flag
```

#### level4

通过模不互素分解得到p、q1、q2，计算`phi1 = (p-1)*(q1-1)`和`phi2 = (p-1)*(q2-1)`，并且`gcd(e1,phi1) = gcd(e2,phi2) = 14`，最后可以转换成`c = m^14 mod q1q2`

```python
n1 = 0xb08bab371e516b9ac3a9c68bc2af143893aac7534ace6c172c6da6e8c7b8b0631819b2647b92d33c064bef0f6af50736a3897b7230771c315f4c4a7315c23691e5b859764f5968e9e623ac768d14bf4cdb9b56fb5b5d53236bf13a7b50bb247a9fe30e5d16c6c7ff34f875677a9438e2f1d0e4dee48c0141e697fef3881d91249ecf9c415d3846bbd8bf9ddec2229f7a13e3b0c085ec1073bc4b7d2654115967798244068e78bf2d150e702766ba7508d19346671a468943ca74509cb4fd7f8099b6a69f90f4ecf7326efc5584ebae592d3bc4ed54f5edd9c33f7a1880fa24f96a8317e52986fed69950f4243422e1ede448ba72894201ea47e23ec8157cf507L
n2 = 0xae8a5a3e9946f573c2b89167d2c4f7f630889c05a38b64f6f8ffe3e5230c946a065c19eab4f0b8caa75fdb3fdaa1e4f0e5f89baff4398c1a1fd32b292ac1c1d87a718c8ae3f58c2e6f97eb459dbaf1ffdc00d8b6e915c84c11dec00120308dc6e2b6778b953df6d9f454053c25db701987b89ece4de709a1b345a7528c4245ae3965b8ef29abcb278dc941fea5cbb369c74434c7b1e873ee2f6dc18bc5a69692358bf9443edb6b2eaeb674407ef763c62d57468e99408ef2fbb73699908e532de91689e07b77d12be0a425686b21aff40287749e391b4f46abecccba99d59d4ed861f57f1c520e888252be390245029808f07bfbd6e5200adff705b8255c93adL
c1 = 0x68efd78bd67438de2474bb1b9112e305266245359807dda408e9937bc97ee06d0098a8823cc49c562392361d15852f5dce226cc0651da86654228ed9c6a2cb4952b8b447f4deaff8b622030f41f3e506431362c7900c32f0e6e53b4eb43b6ab6358e1fdfd03bead43d61d35d292ef9f575dd7507ad24838ff27be4bf9f8221bf5eeccb460168c3f2d703edc8733a40d0d890cdb9584bb454886c74cdd69dee19855b80789ffe74088326f963e24c31c8e293f630cb6bac282ac49ad142c4d4fd90b272abe924ffa72c1b974cd90e0a41c80b40df6f492b63edb792cc48ff30e5aad7e5a1d8c021a1705c27692bf07f836530627f0a178b93b626ac6ebad06a71L
c2 = 0x3a9e0e7765e488f6f6651fa9758b99329beb2fb8117e990683e833a4c0a8203621fe69790ebcd4e99b7c7135753c6a6e785a206c6f668c541600f075a67d1df77c536e0659a6aee5291726da62b6b19d35bb3429eb5af41ee9b60c0f7ae28cb983428c7041fec0b5649dde69355c12795ed2a539458991164b35b37fa2495d8df80710cb75b64ae9ecfddf80fb188df864acac136c0cb9db0953e5328280ccbcd3dc8c32755045ffe0e59f38d3a5d2507d4123789681534d4a69020ad984839db68d437f0a5fc4542b5856e8845afa890e18217b34e4095511abe10787268aac55ceed1453fc5dc5c97593a4374b6603c439638c604c53282a6fb3f327a72518L
e1 = 0x4628a2
e2 = 0x1436ea

p = gmpy2.gcd(n1,n2)

q1 = n1 // p
q2 = n2 // p
phi1 = (p-1)*(q1-1)
phi2 = (p-1)*(q2-1)

e1 = e1 // 14
e2 = e2 // 14
d1 = gmpy2.invert(e1,phi1)
d2 = gmpy2.invert(e2,phi2)

f1 = pow(c1,d1,n1)
f2 = pow(c2,d2,n2)

def GCRT(mi, ai):
    # mi,ai分别表示模数和取模后的值,都为列表结构
    assert (isinstance(mi, list) and isinstance(ai, list))
    curm, cura = mi[0], ai[0]
    for (m, a) in zip(mi[1:], ai[1:]):
        d = gmpy2.gcd(curm, m)
        c = a - cura
        assert (c % d == 0) #不成立则不存在解
        K = c // d * gmpy2.invert(curm // d, m // d)
        cura += curm * K
        curm = curm * m // d
        cura %= curm
    return (cura % curm, curm) #(解,最小公倍数)

f3,lcm = GCRT([n1,n2],[f1,f2])
assert(f3 % n1 == f1)
assert(f3 % n2 == f2)
assert(lcm == q1*q2*p)

n3 = q1*q2
c3 = f3 % n3
phi3 = (q1-1)*(q2-1)

assert(gmpy2.gcd(7,phi3) == 1)

d3 = gmpy2.invert(7,phi3)
m3 = pow(c3,d3,n3)

if gmpy2.iroot(m3,2)[1] == 1:
    flag = gmpy2.iroot(m3,2)[0]
    print flag
```

#### level5

本意是想考related message attack，但是师傅们好像都是用开方做出来的，给大佬们递茶

```python
def short_pad_attack(c1, c2, e, n):
    PRxy.<x,y> = PolynomialRing(Zmod(n))
    PRx.<xn> = PolynomialRing(Zmod(n))
    PRZZ.<xz,yz> = PolynomialRing(Zmod(n))

    g1 = x ^ e - c1
    g2 = (x + y) ^ e - c2
    q1 = g1.change_ring(PRZZ)
    q2 = g2.change_ring(PRZZ)
    h = q2.resultant(q1)
    h = h.univariate_polynomial()
    h = h.change_ring(PRx).subs(y=xn)
    h = h.monic()
    kbits = n.nbits() // (2 * e * e)
    diff = h.small_roots(X=2 ^ kbits, beta=0.5)[0]  # find root < 2^kbits with factor >= n^0.5
    return diff

def related_message_attack(c1, c2, diff, e, n):
    PRx.<x> = PolynomialRing(Zmod(n))
    g1 = x ^ e - c1
    g2 = (x + diff) ^ e - c2

    def gcd(g1, g2):
        while g2:
            g1, g2 = g2, g1 % g2
        return g1.monic()

    return -gcd(g1, g2)[0]

if __name__ == '__main__':
    n = 19442176928007830098424428955804863422490104569894359496453939957229742423661160054241621640185600142526048820896573841917260538353760477502624635228772623542594808126714949387688256798485777301116254045665123490080599759063595943183174257000621175533455527351901382362223186460177724406923578989734811261651935021211994078268472388527276207734500306479937257181713076303044191424255541575089667633199235148135321345062563193566412742338012981130056909856454878804112411630977554868340858807585375893503827768149367059669895608437969230531174624250114738703422569825794356115744480899464005839030338854022395818875403
    e = 5

    nbits = n.nbits()
    kbits = nbits // (2 * e * e)
    print "upper %d bits (of %d bits) is same" % (nbits - kbits, nbits)

    # ^^ = bit-wise XOR
    # http://doc.sagemath.org/html/en/faq/faq-usage.html#how-do-i-use-the-bitwise-xor-operator-in-sage

    c1 = 265062189690110258168937914660953141176262450217439754228412476921446090800865485245586374925301693092500339299234605734070010071396874397183777663814494638701287154485422437592402905249840040151974080315867776147021284075889623873125652375381248465118406871808612192648463354603146409805633298150440609502952012219466107223073722611710202703260376132210869385568895215174665401985520571514194067663539459950606936108462665901877112231914464806764529803480944795681849082656461363871269771058326378629532466874107079842249414630772189064960956110663544293311957887794906286805610383928125
    c2 = 265062189690110258168937914660953141176262450217439754228412476921446090800865485245586374925301693092500339299234590972683684007932856122076633527469285284664876765956238156745882235870289890666905903061370680974052073327856401906558796495792640707398188184589372197560239909882241253361848467451770502253350255829962879608858461099793337589915413779774088831454734857389908802396033544417778902965804114905575051102617369791505746948583147955602054499061020529118234065874742791346925068898605296740979453445839143999750142181455751998618406840614227878335038410646539032726011271740251

    diff = short_pad_attack(c1, c2, e, n)
    print "difference of two messages is %d" % diff
    m1 = related_message_attack(c1, c2, diff, e, n)
    m2 = m1 + diff
    print "m1 is %d" % m1
    print "m2 is %d" % m2
    
#My password is: Orz_I_Wi1l_Alway3_Lov5_R3A_Sy3tem
```

